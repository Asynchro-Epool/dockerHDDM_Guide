scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Effect of valence on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
# (p_rt1 | p_dprime1)
p_rt1 + p_dprime1 +
p_rt1_diff + p_dprime1_diff + plot_annotation(tag_levels = 'A')  + plot_layout(nrow = 2, byrow = TRUE)
# (p_rt1 | p_dprime1)
p_ms_rt1 + p_ms_dprime1 +
p_ms_dprime1_diff_val + p_ms_rt1_diff_val +
p_ms_dprime1_diff_id + p_ms_rt1_diff_id + plot_annotation(tag_levels = 'A')  + plot_layout(nrow = 3, byrow = TRUE)
p_ms_dprime1_diff_id <- df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
ggplot2::ggplot(aes(y = condition, x = value, fill = stat(x > 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Self-referential effect on ", italic("d"), " prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_dprime1_diff_id
# plot the posterior of matching trials, diff between self and other
p_ms_rt1_diff_id <- df_ms_m1_plot_rt_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
dplyr::filter((value >= -200) & (value <= 200)) %>%
ggplot2::ggplot(aes(y = condition, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Self referential effect on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_rt1_diff_id
df_ms_m1_plot_rt_diff <- df_ms_m1_plot_rt %>%
tidyr::pivot_wider(names_from = c(term), values_from = value) %>%   # long to wide
# calculate the difference between conditions, matched trials only
dplyr::mutate(diff_GN_M_S = M_Self_Good - M_Self_Neutral,               # calculate the differences between conditions
diff_BN_M_S = M_Self_Bad - M_Self_Neutral,
diff_GN_M_O = M_Other_Good - M_Other_Neutral,
diff_BN_M_O = M_Other_Bad - M_Other_Neutral,
diff_SO_G   = M_Self_Good - M_Other_Good,
diff_SO_N   = M_Self_Neutral - M_Other_Neutral,
diff_SO_B   = M_Self_Bad - M_Other_Bad) %>%
dplyr::select(condition, `.chain`, `.iteration`, `.draw`,
diff_GN_M_S, diff_BN_M_S, diff_GN_M_O,
diff_BN_M_O, diff_SO_G, diff_SO_B) %>%
tidyr::pivot_longer(cols = diff_GN_M_S:diff_SO_B, names_to = "term_diff", values_to =  "value")  %>%  # wide to long
dplyr::mutate(term_diff = factor(term_diff, levels = c('diff_GN_M_S','diff_BN_M_S', 'diff_GN_M_O', 'diff_BN_M_O',
'diff_SO_G', 'diff_SO_N', 'diff_SO_B')))
# plot the posterior of matching trials, diff between self and other
p_ms_rt1_diff_id <- df_ms_m1_plot_rt_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
dplyr::filter((value >= -200) & (value <= 200)) %>%
ggplot2::ggplot(aes(y = condition, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Self referential effect on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_rt1_diff_id
df_ms_m1_plot_rt_diff <- df_ms_m1_plot_rt %>%
tidyr::pivot_wider(names_from = c(term), values_from = value) %>%   # long to wide
# calculate the difference between conditions, matched trials only
dplyr::mutate(diff_GN_M_S = M_Self_Good - M_Self_Neutral,               # calculate the differences between conditions
diff_BN_M_S = M_Self_Bad - M_Self_Neutral,
diff_GN_M_O = M_Other_Good - M_Other_Neutral,
diff_BN_M_O = M_Other_Bad - M_Other_Neutral,
diff_SO_G   = M_Self_Good - M_Other_Good,
diff_SO_N   = M_Self_Neutral - M_Other_Neutral,
diff_SO_B   = M_Self_Bad - M_Other_Bad) %>%
dplyr::select(condition, `.chain`, `.iteration`, `.draw`,
diff_GN_M_S, diff_BN_M_S, diff_GN_M_O,
diff_BN_M_O, diff_SO_G, diff_SO_N, diff_SO_B) %>%
tidyr::pivot_longer(cols = diff_GN_M_S:diff_SO_B, names_to = "term_diff", values_to =  "value")  %>%  # wide to long
dplyr::mutate(term_diff = factor(term_diff, levels = c('diff_GN_M_S','diff_BN_M_S', 'diff_GN_M_O', 'diff_BN_M_O',
'diff_SO_G', 'diff_SO_N', 'diff_SO_B')))
# plot the posterior of matching trials, diff between self and other
p_ms_rt1_diff_id <- df_ms_m1_plot_rt_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
dplyr::filter((value >= -200) & (value <= 200)) %>%
ggplot2::ggplot(aes(y = condition, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Self referential effect on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_rt1_diff_id
# plot the posterior of matching trials of valence
p_ms_rt1_diff_val <- df_ms_m1_plot_rt_diff %>%
dplyr::filter(str_detect(term_diff, '_M_')) %>%
dplyr::filter((value >= -200) & (value <= 200)) %>%
ggplot2::ggplot(aes(y = condition, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Effect of valence on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_rt1_diff_val
# (p_rt1 | p_dprime1)
p_ms_rt1 + p_ms_dprime1 +
p_ms_dprime1_diff_val + p_ms_rt1_diff_val +
p_ms_dprime1_diff_id + p_ms_rt1_diff_id + plot_annotation(tag_levels = 'A')  + plot_layout(nrow = 3, byrow = TRUE)
p_ms_rt1 + p_ms_dprime1 +
p_ms_dprime1_diff_val + p_ms_rt1_diff_val +
p_ms_dprime1_diff_id + p_ms_rt1_diff_id + plot_annotation(tag_levels = 'A')  + plot_layout(nrow = 3, byrow = TRUE)
df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Self-referential effect on ", italic("d"), " prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Self-referential effect on ", italic("d"), " prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_dprime1_diff_val <- df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_dprm_S|_dprm_O')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Valence effect on", italic("d"), "prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_dprime1_diff_id <- df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Self-referential effect on ", italic("d"), " prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
# plot the posterior of matching trials of valence
p_ms_rt1_diff_val <- df_ms_m1_plot_rt_diff %>%
dplyr::filter(str_detect(term_diff, '_M_')) %>%
dplyr::filter((value >= -200) & (value <= 200)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Effect of valence on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
# plot the posterior of matching trials, diff between self and other
p_ms_rt1_diff_id <- df_ms_m1_plot_rt_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
dplyr::filter((value >= -200) & (value <= 200)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x < 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab("Self referential effect on RT (Match trials)") +
facet_wrap( ~ term_diff,
# scales = "free_y",
nrow = 1,
labeller = label_parsed)
# (p_rt1 | p_dprime1)
p_ms_rt1 + p_ms_dprime1 +
p_ms_dprime1_diff_val + p_ms_rt1_diff_val +
p_ms_dprime1_diff_id + p_ms_rt1_diff_id + plot_annotation(tag_levels = 'A')  + plot_layout(nrow = 3, byrow = TRUE)
p_ms_dprime1_diff_val <- df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_dprm_S|_dprm_O')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x > 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Valence effect on ", italic("d"), " prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
p_ms_dprime1_diff_id <- df_ms_sdt_m1_plot_diff %>%
dplyr::filter(str_detect(term_diff, '_SO_')) %>%
#dplyr::filter(!str_detect(term_diff, '_GB_')) %>%
# tidyr::unite(term_diff, c('Identity', 'term_diff')) %>%
dplyr::filter((value >= -1.5) & (value <= 1.5)) %>%
dplyr::rename(Experiments = condition) %>%
ggplot2::ggplot(aes(y = Experiments, x = value, fill = stat(x > 0))) +
tidybayes::stat_halfeye() +
geom_vline(xintercept = 0, linetype = "dashed") +
scale_fill_manual(values = c('gray80', 'skyblue')) +
xlab(expression(paste("Self-referential effect on ", italic("d"), " prime", sep = ' '))) +
facet_wrap( ~ term_diff, # scales = "free_y",
nrow = 1,
labeller = label_parsed)
# (p_rt1 | p_dprime1)
p_ms_rt1 + p_ms_dprime1 +
p_ms_dprime1_diff_val + p_ms_rt1_diff_val +
p_ms_dprime1_diff_id + p_ms_rt1_diff_id + plot_annotation(tag_levels = 'A')  + plot_layout(nrow = 3, byrow = TRUE)
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
library(posterior)
check_cmdstan_toolchain()
install_cmdstan(cores = 8)
cmdstan_path()
cmdstan_version()
setwd('/media/hcp4715/T3/Exp_Statistics/Rethinking')
setwd('./trans_CN')
getwd()
setwd("/home/hcp4715/HCP_could/Exp_Modelling_DDM/tutorial/temp")
setwd("/home/hcp4715/HCP_cloud/Exp_Modelling_DDM/tutorial/temp")
setwd("/home/hcp4715/HCP_cloud/Exp_Modelling/DDM/tutorial/temp")
setwd("/home/hcp4715/HCP_cloud/Exp_Modeling/DDM/tutorial/temp")
df <- read.csv('df_HC_0_bf.csv')
library(bayestestR)
View(df)
df <- read.csv('df_HC_0_bf.csv')
View(df)
library(bayestestR)
bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0)
install.packages('logspline)
install.packages('logspline')
bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0)
bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0, plot=TRUE)
plot(bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0) )
install.packages('see')
plot(bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0) )
print(bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0, plot=TRUE))
bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0, plot=TRUE)
plot(bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0) )
df <- read.csv('df_HC_0_bf.csv')
library(bayestestR)
df <- read.csv('df_HC_0_bf.csv')
bayesfactor_parameters(posterior = df$posterior, prior = df$prior, null = 0, plot=TRUE)
View(df)
bayesfactor_parameters(posterior = df$posterior, prior = df$prior_def, null = 0, plot=TRUE)
bayesfactor_parameters(posterior = df$posterior, prior = df$prior_inf, null = 0, plot=TRUE)
.logspline
?logspline
?dlogspline
dlogspline(0, df$posterior)
logspline::dlogspline(0, df$posterior)
logspline::dlogspline(0, logspline::logspline(df$posterior))
logspline::dlogspline(0, logspline::logspline(df$prior_def))
logspline::dlogspline(0, logspline::logspline(df$prior_inf))
plot(logspline::logspline(df$prior_inf)))
plot(logspline::logspline(df$prior_inf))
plot(logspline::logspline(rnorm(5000)))
logspline::plogspline(0, logspline::logspline(df$posterior))
logspline::plogspline(0, logspline::logspline(df$prior_def))
logspline::plogspline(0, logspline::logspline(df$prior_inf))
logspline::plogspline(0, logspline::logspline(df$posterior))/logspline::plogspline(0, logspline::logspline(df$prior_def))
logspline::plogspline(0, logspline::logspline(df$posterior))/logspline::plogspline(0, logspline::logspline(df$prior_inf))
bayesfactor_parameters(posterior = df$posterior, prior = df$prior_def, null = 0, plot=TRUE)
logspline::plogspline(0, logspline::logspline(df$posterior))/logspline::plogspline(0, logspline::logspline(df$prior_def))
logspline::plogspline(0, logspline::logspline(df$posterior))/logspline::plogspline(0, logspline::logspline(df$prior_inf))
bayesfactor_parameters(posterior = df$posterior, prior = df$prior_inf, null = 0, plot=TRUE)
library(tidyverse)
library(loo)
library(tidyverse)
library(loo)
LLarr <- example_loglik_array()
rel_n_eff <- relative_eff(exp(LLarr))
loo(LLarr, r_eff = rel_n_eff, cores = 2)
# Simulate data and draw from posterior
N <- 50; K <- 10; S <- 100; a0 <- 3; b0 <- 2
p <- rbeta(1, a0, b0)
y <- rbinom(N, size = K, prob = p)
set.seed(124)
# Simulate data and draw from posterior
N <- 50; K <- 10; S <- 100; a0 <- 3; b0 <- 2
p <- rbeta(1, a0, b0)
y <- rbinom(N, size = K, prob = p)
a <- a0 + sum(y); b <- b0 + N * K - sum(y)
fake_posterior <- as.matrix(rbeta(S, a, b))
dim(fake_posterior) # S x 1
#> [1] 100   1
fake_data <- data.frame(y,K)
dim(fake_data)
llfun <- function(data_i, draws) {
# each time called internally within loo the arguments will be equal to:
# data_i: ith row of fake_data (fake_data[i,, drop=FALSE])
# draws: entire fake_posterior matrix
dbinom(data_i$y, size = data_i$K, prob = draws, log = TRUE)
}
# Use the loo_i function to check that llfun works on a single observation
# before running on all obs. For example, using the 3rd obs in the data:
loo_3 <- loo_i(i = 3, llfun = llfun, data = fake_data, draws = fake_posterior, r_eff = NA)
print(loo_3$pointwise[, "elpd_loo"])
# Use loo.function method (setting r_eff=NA since this posterior not obtained via MCMC)
loo_with_fn <- loo(llfun, draws = fake_posterior, data = fake_data, r_eff = NA)
# If we look at the elpd_loo contribution from the 3rd obs it should be the
# same as what we got above with the loo_i function and i=3:
print(loo_with_fn$pointwise[3, "elpd_loo"])
#>  elpd_loo
#> -1.267103
print(loo_3$pointwise[, "elpd_loo"])
library(rstan)
# we recommend running this is a fresh R session or restarting your current session
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
library(posterior)
library(bayesplot)
color_scheme_set("brightblue")
check_cmdstan_toolchain()
cmdstan_path()
install_cmdstan(cores = 4)
cmdstan_path()
file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod <- cmdstan_model(file)
mod$print()
data {
int<lower=0> N;
array[N] int<lower=0,upper=1> y; // or int<lower=0,upper=1> y[N];
}
parameters {
real<lower=0,upper=1> theta;
}
model {
theta ~ beta(1,1);  // uniform prior on interval 0,1
y ~ bernoulli(theta);
}
mod$exe_file()
data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))
fit <- mod$sample(
data = data_list,
seed = 123,
chains = 4,
parallel_chains = 4,
refresh = 500 # print update every 500 iters
)
fit$summary()
fit$summary(variables = c("theta", "lp__"), "mean", "sd")
# we'll add an argument log to toggle whether this is a log-likelihood or
# likelihood function. this will be useful later in the vignette.
llfun_logistic <- function(data_i, draws, log = TRUE) {
x_i <- as.matrix(data_i[, which(grepl(colnames(data_i), pattern = "X")), drop=FALSE])
logit_pred <- draws %*% t(x_i)
dbinom(x = data_i$y, size = 1, prob = 1/(1 + exp(-logit_pred)), log = log)
}
# Prepare data
url <- "http://stat.columbia.edu/~gelman/arm/examples/arsenic/wells.dat"
wells <- read.table(url)
wells$dist100 <- with(wells, dist / 100)
X <- model.matrix(~ dist100 + arsenic, wells)
standata <- list(y = wells$switch, X = X, N = nrow(X), P = ncol(X))
View(standata)
cmdsta_mod <- cmdstan_model("logistic.stan")
fit_1 <- cmdsta_mod$sample(
data = standata,
seed = 4711,
chains = 4,
parallel_chains = 4,
refresh = 500 # print update every 500 iters
)
print(fit_1, pars = "beta")
View(fit_1)
# Compile
stan_mod <- stan_model("logistic.stan")
# Compile
stan_mod <- stan_model("logistic.stan")
# Fit model
fit_1 <- sampling(stan_mod, data = standata, seed = 4711)
?sampling
# Fit model
fit_1 <- sampling(stan_mod, data = standata, seed = 4711, cores = 4)
# fit_1 <- cmdsta_mod$sample(
#   data = standata,
#   seed = 4711,
#   chains = 4,
#   parallel_chains = 4,
#   refresh = 500 # print update every 500 iters
# )
print(fit_1, pars = "beta")
# used for draws argument to loo_i
parameter_draws_1 <- extract(fit_1)$beta
# used for data argument to loo_i
stan_df_1 <- as.data.frame(standata)
View(stan_df_1)
# compute relative efficiency (this is slow and optional but is recommended to allow
# for adjusting PSIS effective sample size based on MCMC effective sample size)
r_eff <- relative_eff(llfun_logistic,
log = FALSE, # relative_eff wants likelihood not log-likelihood values
chain_id = rep(1:4, each = 1000),
data = stan_df_1,
draws = parameter_draws_1,
cores = 2)
loo_i(i = 1, llfun_logistic, r_eff = r_eff, data = stan_df_1, draws = parameter_draws_1)
set.seed(4711)
loo_ss_1 <-
loo_subsample(
llfun_logistic,
observations = 100, # take a subsample of size 100
cores = 2,
# these next objects were computed above
r_eff = r_eff,
draws = parameter_draws_1,
data = stan_df_1
)
print(loo_ss_1)
set.seed(4711)
loo_ss_1b <-
update(
loo_ss_1,
observations = 200, # subsample 200 instead of 100
r_eff = r_eff,
draws = parameter_draws_1,
data = stan_df_1
)
print(loo_ss_1b)
```{r specify subsampling method}
set.seed(4711)
loo_ss_1c <-
loo_subsample(
x = llfun_logistic,
r_eff = r_eff,
draws = parameter_draws_1,
data = stan_df_1,
observations = 100,
estimator = "hh_pps", # use Hansen-Hurwitz
loo_approximation = "lpd", # use lpd instead of plpd
loo_approximation_draws = 100,
cores = 2
)
print(loo_ss_1c)
View(fit_1)
fit_2 <- cmdsta_mod$sample(
data = standata,
seed = 4711,
chains = 4,
parallel_chains = 4,
refresh = 500 # print update every 500 iters
)
View(fit_2)
fit_2
print(fit_1, pars = "beta")
summary(fit2)
summary(fit_2)
fit_2
fit_2$summary()
fit_2$draws()
fit_2$draws(variables = "beta")
parameter_draws_2 <- fit_2$draws(variables = "beta", format = "df")
View(parameter_draws_2)
parameter_draws_1
class(parameter_draws_1)
parameter_draws_2 <- fit_2$draws(variables = "beta", format = "matrix")
View(parameter_draws_2)
View(parameter_draws_1)
# compute relative efficiency (this is slow and optional but is recommended to allow
# for adjusting PSIS effective sample size based on MCMC effective sample size)
r_eff <- relative_eff(llfun_logistic,
log = FALSE, # relative_eff wants likelihood not log-likelihood values
chain_id = rep(1:4, each = 1000),
data = stan_df_1,
draws = parameter_draws_2,
cores = 2)
loo_i(i = 1, llfun_logistic, r_eff = r_eff, data = stan_df_1, draws = parameter_draws_1)
rm(list = ls())
library(tidyverse)
library(rstan)
library(loo)
?relative_eff
?loo_i
?S3
methods(summary())
methods(summary
)
